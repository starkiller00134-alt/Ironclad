<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>Ironclad — Combat Prototype</title>
  <style>
    :root{
      --bg:#0b0b10;
      --panel:#12121a;
      --panel2:#151522;
      --ink:#e9e9f2;
      --muted:#a6a6c2;
      --accent:#8a7dff;
      --accent2:#4ee59a;
      --danger:#ff5d7a;
      --shadow: 0 12px 40px rgba(0,0,0,.55);
      --r:18px;
      --px: 2px; /* pixel upscale */
      --font: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    }

    html,body{height:100%;background: radial-gradient(1200px 700px at 50% 0%, #141425 0%, var(--bg) 55%) fixed; color:var(--ink); margin:0; font-family:var(--font);}
    .wrap{max-width:980px;margin:0 auto;padding:14px 12px 22px; display:flex; flex-direction:column; gap:12px;}
    .topbar{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    }
    .chip{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.12);
      border-radius:999px;
      padding:10px 12px;
      box-shadow: var(--shadow);
      color:var(--ink);
      display:inline-flex; gap:8px; align-items:center;
      font-size:13px;
    }
    .chip b{font-weight:700;}
    .btn{
      -webkit-tap-highlight-color: transparent;
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.03));
      border:1px solid rgba(255,255,255,.14);
      color:var(--ink);
      border-radius:14px;
      padding:12px 14px;
      font-family:var(--font);
      font-size:16px;
      box-shadow: var(--shadow);
      cursor:pointer;
      user-select:none;
    }
    .btn:active{transform:translateY(1px);}
    .btn.secondary{opacity:.92}
    .btn.purple{border-color: rgba(138,125,255,.45); box-shadow:0 14px 40px rgba(138,125,255,.14);}
    .btn.green{border-color: rgba(78,229,154,.45); box-shadow:0 14px 40px rgba(78,229,154,.12);}
    .btn.red{border-color: rgba(255,93,122,.45); box-shadow:0 14px 40px rgba(255,93,122,.12);}
    .btn:disabled{opacity:.45; filter:saturate(.7); cursor:not-allowed; transform:none;}

    .grid{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:12px;
    }
    @media (max-width:880px){
      .grid{grid-template-columns:1fr; }
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.10);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card .hd{
      padding:12px 12px 10px;
      display:flex; justify-content:space-between; align-items:center; gap:10px;
      border-bottom:1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.12);
    }
    .title{
      display:flex; flex-direction:column; gap:2px;
    }
    .title .k{font-size:12px;color:var(--muted);}
    .title .v{font-size:14px;font-weight:700; letter-spacing:.3px;}
    .content{padding:12px;}

    /* Pixel canvas wrapper */
    .stageWrap{padding:12px; display:flex; flex-direction:column; gap:10px;}
    .stageTop{
      display:flex; justify-content:space-between; align-items:flex-start; gap:10px; flex-wrap:wrap;
    }
    .stageTop .statPill{
      background:rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.12);
      border-radius:14px;
      padding:10px 10px;
      min-width: 240px;
    }
    .row{display:flex; justify-content:space-between; gap:10px; align-items:center; font-size:13px;}
    .row .muted{color:var(--muted);}
    .bars{margin-top:8px; display:flex; flex-direction:column; gap:7px;}
    .bar{
      height:10px;
      background: rgba(255,255,255,.08);
      border:1px solid rgba(0,0,0,.35);
      border-radius:999px;
      overflow:hidden;
      position:relative;
    }
    .bar>span{
      position:absolute; left:0; top:0; bottom:0;
      width:50%;
      border-radius:999px;
    }
    .bar.hp>span{background: linear-gradient(90deg, rgba(255,93,122,.95), rgba(255,93,122,.55));}
    .bar.mp>span{background: linear-gradient(90deg, rgba(138,125,255,.95), rgba(138,125,255,.55));}

    .battleFrame{
      position:relative;
      width:100%;
      aspect-ratio: 16 / 9;
      background: radial-gradient(900px 500px at 50% 30%, rgba(78,229,154,.12) 0%, rgba(0,0,0,0) 60%),
                  linear-gradient(180deg, rgba(0,0,0,.10), rgba(0,0,0,.25));
      border:1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      overflow:hidden;
    }

    /* This canvas is pixel art; we scale it up with image-rendering */
    canvas{
      width:100%;
      height:100%;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      display:block;
    }

    /* Center-lower HUD near character */
    .hudNear{
      position:absolute;
      left: 14%;
      bottom: 10%;
      transform: translateX(-0%);
      width:min(360px, 70%);
      pointer-events:none;
      background: rgba(0,0,0,.28);
      border:1px solid rgba(255,255,255,.12);
      border-radius:14px;
      padding:10px 10px;
      backdrop-filter: blur(2px);
    }

    .log{
      font-size:15px;
      line-height:1.45;
      color:var(--ink);
      background: rgba(0,0,0,.20);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      padding:12px;
      min-height:140px;
      white-space:pre-wrap;
    }

    .actions{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:10px;
    }
    .actions .btn{padding:14px 12px; font-size:18px;}
    .sub{
      margin-top:8px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:space-between;
      align-items:center;
    }
    .hint{color:var(--muted); font-size:12px;}
    .targets{display:flex; gap:10px; width:100%;}
    .targets .btn{flex:1; font-size:15px; padding:12px;}
    .badge{
      padding:4px 8px;border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      color:var(--muted);
      font-size:12px;
    }
    .turn{
      color: var(--accent2);
      font-weight:700;
    }
  </style>
</head>
<body>
<div class="wrap">

  <div class="topbar">
    <div class="chip"><b>IRONCLAD</b></div>
    <div class="chip"><span class="muted">Combat Prototype</span> <b>v0.2</b></div>
    <button class="btn purple" id="startBtn">Start / Continue</button>
    <button class="btn secondary" id="resetBtn">Reset Battle</button>
    <button class="btn secondary" id="debugBtn">Debug: OFF</button>
  </div>

  <div class="grid">

    <div class="card">
      <div class="hd">
        <div class="title">
          <div class="k">Battlefield</div>
          <div class="v">Side-angled top view • Tap an enemy to target</div>
        </div>
        <div class="badge" id="roundBadge">Round 1</div>
      </div>

      <div class="stageWrap">
        <div class="battleFrame" id="battleFrame">
          <canvas id="c"></canvas>

          <!-- HUD near player (center-lower-ish) -->
          <div class="hudNear">
            <div class="row">
              <div><b id="pName">Salem The Pib cox</b></div>
              <div class="muted">Lvl <span id="pLvl">7</span> • XP <span id="pXp">25</span></div>
            </div>
            <div class="bars">
              <div class="row"><span class="muted">HP</span><span class="muted"><span id="pHpNow">32</span>/<span id="pHpMax">32</span></span></div>
              <div class="bar hp"><span id="pHpBar"></span></div>
              <div class="row"><span class="muted">MP</span><span class="muted"><span id="pMpNow">25</span>/<span id="pMpMax">25</span></span></div>
              <div class="bar mp"><span id="pMpBar"></span></div>
            </div>
          </div>
        </div>

        <div class="log" id="log"></div>

      </div>
    </div>

    <div class="card">
      <div class="hd">
        <div class="title">
          <div class="k">Actions</div>
          <div class="v">Turn-based • Order: <span class="turn">Salem ×2 → Enemy 1 → Enemy 2</span></div>
        </div>
        <div class="badge" id="phaseBadge">Paused</div>
      </div>

      <div class="content">
        <div class="actions">
          <button class="btn" id="slashBtn">Slash</button>
          <button class="btn" id="fireBtn">Fire</button>
          <button class="btn" id="waterBtn">Water</button>
          <button class="btn green" id="healBtn">Heal</button>
        </div>

        <div class="sub">
          <div class="hint" id="hint">Tap <b>Start / Continue</b> to begin. Then choose a target and an action.</div>
        </div>

        <div style="height:10px"></div>

        <div class="targets">
          <button class="btn purple" id="t1Btn">Target: Enemy 1</button>
          <button class="btn purple" id="t2Btn">Target: Enemy 2</button>
        </div>

        <div style="height:10px"></div>
        <div class="hint">
          Enemy stats are hidden (background) for now — you’ll learn them through damage and behavior.
        </div>

      </div>
    </div>

  </div>
</div>

<script>
(() => {
  // -------------------------
  // State / Rules (Joseph spec)
  // -------------------------
  const RNG = (a,b)=> Math.floor(Math.random()*(b-a+1))+a;

  const player = {
    name: "Salem The Pib cox",
    hp: 32, hpMax: 32,
    mp: 25, mpMax: 25,
    lvl: 7, xp: 25
  };

  function makeEnemy(type, label){
    if(type==="slime") return { type, label, hp:15, hpMax:15, alive:true };
    if(type==="bandit") return { type, label, hp:15, hpMax:15, alive:true };
    if(type==="wisp") return { type, label, hp:15, hpMax:15, alive:true };
    if(type==="engorge") return {
      type, label,
      hp:60, hpMax:60, alive:true,
      mindflayCounter: 0
    };
    return { type, label, hp:15, hpMax:15, alive:true };
  }

  let enemies = [ makeEnemy("slime","Enemy 1"), makeEnemy("bandit","Enemy 2") ];

  // Turn order: Salem (action 1), Salem (action 2), Enemy 1, Enemy 2
  // No continuous loop; it advances only when you press Start/Continue or take an action.
  const turnOrder = ["P1","P2","E1","E2"];
  let turnIndex = 0;

  let running = false;        // must be true to act
  let waitingForPlayer = true; // when current turn is P1 or P2
  let targetIndex = 0;        // 0 or 1
  let round = 1;
  let debug = false;

  // -------------------------
  // UI handles
  // -------------------------
  const logEl = document.getElementById("log");
  const startBtn = document.getElementById("startBtn");
  const resetBtn = document.getElementById("resetBtn");
  const debugBtn = document.getElementById("debugBtn");
  const phaseBadge = document.getElementById("phaseBadge");
  const roundBadge = document.getElementById("roundBadge");
  const hintEl = document.getElementById("hint");

  const slashBtn = document.getElementById("slashBtn");
  const fireBtn  = document.getElementById("fireBtn");
  const waterBtn = document.getElementById("waterBtn");
  const healBtn  = document.getElementById("healBtn");

  const t1Btn = document.getElementById("t1Btn");
  const t2Btn = document.getElementById("t2Btn");

  // Player HUD
  const pName = document.getElementById("pName");
  const pLvl  = document.getElementById("pLvl");
  const pXp   = document.getElementById("pXp");
  const pHpNow= document.getElementById("pHpNow");
  const pHpMax= document.getElementById("pHpMax");
  const pMpNow= document.getElementById("pMpNow");
  const pMpMax= document.getElementById("pMpMax");
  const pHpBar= document.getElementById("pHpBar");
  const pMpBar= document.getElementById("pMpBar");

  // Canvas
  const canvas = document.getElementById("c");
  const frame = document.getElementById("battleFrame");
  const ctx = canvas.getContext("2d");

  // Internal pixel resolution (fixed for crisp art)
  const W = 320, H = 180;
  canvas.width = W;
  canvas.height = H;

  // -------------------------
  // Logging
  // -------------------------
  const LOG_MAX = 10;
  let logLines = [];

  function log(line){
    logLines.push(line);
    if(logLines.length>LOG_MAX) logLines.shift();
    logEl.textContent = logLines.join("\n");
  }

  // -------------------------
  // Rendering (pixel art-ish, no block placeholders)
  // -------------------------
  // Scene layout: angled "field" plane with grid; player + 2 enemies; trees in background.
  // Tap/click enemies on canvas to target.
  const scene = {
    // positions in "field coordinates"
    player: { x: 60, y: 98 },
    enemy1: { x: 230, y: 78 },
    enemy2: { x: 255, y: 98 },
    // selection ring animation
    ringPulse: 0
  };

  // Simple sprites drawn in pixels
  function drawTree(px,py){
    // trunk
    ctx.fillStyle = "#5c3a24";
    ctx.fillRect(px+3, py+8, 3, 7);
    // leaves
    ctx.fillStyle = "#2bd17e";
    ctx.fillRect(px+1, py+2, 7, 7);
    ctx.fillRect(px+0, py+4, 9, 5);
  }

  function drawKnight(px,py){
    // boots
    ctx.fillStyle="#2a2a35";
    ctx.fillRect(px+3,py+18,3,2);
    ctx.fillRect(px+8,py+18,3,2);
    // body
    ctx.fillStyle="#5aa7ff";
    ctx.fillRect(px+3,py+8,8,10);
    // head
    ctx.fillStyle="#d9d9e6";
    ctx.fillRect(px+4,py+4,6,4);
    // helmet stripe
    ctx.fillStyle="#9fa0b8";
    ctx.fillRect(px+4,py+5,6,1);
    // sword
    ctx.fillStyle="#cfd2e6";
    ctx.fillRect(px+12,py+9,2,8);
    ctx.fillStyle="#8a6b3f";
    ctx.fillRect(px+12,py+17,2,2);
    // shield
    ctx.fillStyle="#8a6b3f";
    ctx.fillRect(px+0,py+9,3,7);
    ctx.fillStyle="#3a2a18";
    ctx.fillRect(px+1,py+10,1,5);
  }

  function drawSlime(px,py,color="#7c5bff"){
    // blob
    ctx.fillStyle=color;
    ctx.fillRect(px+1,py+10,12,8);
    ctx.fillRect(px+2,py+8,10,4);
    ctx.fillRect(px+4,py+6,6,3);
    // face
    ctx.fillStyle="#1b1b24";
    ctx.fillRect(px+4,py+12,2,2);
    ctx.fillRect(px+9,py+12,2,2);
    ctx.fillRect(px+6,py+15,3,1);
    // shine
    ctx.fillStyle="rgba(255,255,255,.25)";
    ctx.fillRect(px+3,py+9,3,2);
  }

  function drawBandit(px,py){
    // body
    ctx.fillStyle="#a06a3a";
    ctx.fillRect(px+3,py+9,8,9);
    // head
    ctx.fillStyle="#d9c4aa";
    ctx.fillRect(px+5,py+5,5,4);
    // hood
    ctx.fillStyle="#2b2b35";
    ctx.fillRect(px+4,py+4,7,2);
    ctx.fillRect(px+4,py+4,2,5);
    // dagger
    ctx.fillStyle="#cfd2e6";
    ctx.fillRect(px+12,py+10,2,6);
  }

  function drawSelectionRing(px,py,alive=true){
    if(!alive) return;
    const t = scene.ringPulse;
    const r = 10 + Math.sin(t)*1.2;
    ctx.strokeStyle="rgba(138,125,255,.85)";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.ellipse(px+7, py+18, r, r*0.55, 0, 0, Math.PI*2);
    ctx.stroke();
  }

  function render(){
    // background
    ctx.clearRect(0,0,W,H);

    // sky gradient
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0,"#1a1a2a");
    g.addColorStop(1,"#0e0e16");
    ctx.fillStyle=g;
    ctx.fillRect(0,0,W,H);

    // "field" plane (angled)
    // draw a trapezoid to imply perspective
    ctx.fillStyle="rgba(78,229,154,.10)";
    ctx.beginPath();
    ctx.moveTo(30,55);
    ctx.lineTo(290,55);
    ctx.lineTo(305,140);
    ctx.lineTo(15,140);
    ctx.closePath();
    ctx.fill();

    // grid lines
    ctx.strokeStyle="rgba(255,255,255,.08)";
    ctx.lineWidth=1;
    for(let i=0;i<=10;i++){
      const y = 55 + i*8.5;
      ctx.beginPath();
      ctx.moveTo(30, y);
      ctx.lineTo(290, y);
      ctx.stroke();
    }
    for(let i=0;i<=14;i++){
      const x = 30 + i*18.6;
      ctx.beginPath();
      ctx.moveTo(x,55);
      ctx.lineTo(x+ (i*0.6), 140);
      ctx.stroke();
    }

    // trees (background)
    drawTree(45,45);
    drawTree(265,42);

    // Units
    // player
    drawKnight(scene.player.x, scene.player.y);

    // enemies
    const e1 = enemies[0], e2 = enemies[1];
    if(e1.type==="slime" || e1.type==="wisp" || e1.type==="engorge"){
      drawSlime(scene.enemy1.x, scene.enemy1.y, e1.type==="wisp" ? "#8a7dff" : (e1.type==="engorge" ? "#b56bff" : "#7c5bff"));
    } else {
      drawBandit(scene.enemy1.x, scene.enemy1.y);
    }
    if(e2.type==="slime" || e2.type==="wisp" || e2.type==="engorge"){
      drawSlime(scene.enemy2.x, scene.enemy2.y, e2.type==="wisp" ? "#8a7dff" : (e2.type==="engorge" ? "#b56bff" : "#7c5bff"));
    } else {
      drawBandit(scene.enemy2.x, scene.enemy2.y);
    }

    // selection ring around targeted living enemy
    if(targetIndex===0) drawSelectionRing(scene.enemy1.x, scene.enemy1.y, e1.alive);
    if(targetIndex===1) drawSelectionRing(scene.enemy2.x, scene.enemy2.y, e2.alive);

    // pulse tick
    scene.ringPulse += 0.14;

    // HUD
    pName.textContent = player.name;
    pLvl.textContent = player.lvl;
    pXp.textContent = player.xp;
    pHpNow.textContent = player.hp;
    pHpMax.textContent = player.hpMax;
    pMpNow.textContent = player.mp;
    pMpMax.textContent = player.mpMax;
    pHpBar.style.width = (player.hp / player.hpMax * 100).toFixed(1) + "%";
    pMpBar.style.width = (player.mp / player.mpMax * 100).toFixed(1) + "%";

    // Target button labels
    t1Btn.textContent = "Target: Enemy 1";
    t2Btn.textContent = "Target: Enemy 2";

    // Phase badge
    phaseBadge.textContent = running ? (waitingForPlayer ? "Your turn" : "Enemy turn") : "Paused";
    roundBadge.textContent = "Round " + round;

    // Action availability
    const myTurn = running && (turnOrder[turnIndex] === "P1" || turnOrder[turnIndex] === "P2");
    slashBtn.disabled = !myTurn;
    fireBtn.disabled  = !myTurn;
    waterBtn.disabled = !myTurn;
    healBtn.disabled  = !myTurn;

    if(!running){
      hintEl.innerHTML = 'Tap <b>Start / Continue</b> to begin. Then choose a target and an action.';
    } else if(myTurn){
      hintEl.innerHTML = 'Your turn: choose <b>Slash / Fire / Water / Heal</b>. (Tap an enemy to target.)';
    } else {
      hintEl.innerHTML = 'Enemy is acting. Tap <b>Start / Continue</b> to advance.';
    }

    requestAnimationFrame(render);
  }

  // -------------------------
  // Turn system
  // -------------------------
  function livingEnemyCount(){
    return enemies.filter(e=>e.alive).length;
  }
  function clamp(n,min,max){ return Math.max(min, Math.min(max,n)); }

  function currentToken(){
    return turnOrder[turnIndex];
  }

  function nextTurn(){
    // advance to next valid turn; if round ends, increment
    turnIndex++;
    if(turnIndex >= turnOrder.length){
      turnIndex = 0;
      round++;
      log(`--- Round ${round} ---`);
    }
  }

  function ensureValidTarget(){
    if(enemies[targetIndex] && enemies[targetIndex].alive) return;
    // pick first alive
    const idx = enemies.findIndex(e=>e.alive);
    targetIndex = idx === -1 ? 0 : idx;
  }

  function isBattleOver(){
    if(player.hp<=0) return true;
    if(livingEnemyCount()===0) return true;
    return false;
  }

  function endIfOver(){
    if(player.hp<=0){
      log("Salem has fallen. (Battle Over)");
      running = false;
      return true;
    }
    if(livingEnemyCount()===0){
      log("Enemies defeated. (Battle Over)");
      running = false;
      return true;
    }
    return false;
  }

  // Enemy AI: auto attack 2-6 damage
  function enemyAutoAttack(enemy){
    if(!enemy.alive) return;
    // Special: Engorge has mindflay every 3rd cast + useless accusation move
    if(enemy.type==="engorge"){
      enemy.mindflayCounter = (enemy.mindflayCounter||0)+1;
      if(enemy.mindflayCounter % 3 === 0){
        const loss = Math.floor(player.hp * 0.20);
        const dmg = Math.max(1, loss);
        player.hp = clamp(player.hp - dmg, 1, player.hpMax); // cannot kill
        log(`${enemy.label} casts MINDFLAY. You lose ${dmg} HP (20% of current). It can’t kill.`);
        return;
      } else {
        // accusation move
        log(`${enemy.label} uses "yourdabich". (It does nothing.)`);
        return;
      }
    }

    const dmg = RNG(2,6);
    player.hp = clamp(player.hp - dmg, 0, player.hpMax);
    log(`${enemy.label} attacks for ${dmg} damage.`);
  }

  // Player actions
  function playerAttack(kind){
    if(!running) return;
    const tok = currentToken();
    if(!(tok==="P1"||tok==="P2")) return;

    ensureValidTarget();
    const enemy = enemies[targetIndex];
    if(!enemy || !enemy.alive){
      log("No valid target.");
      return;
    }

    if(kind==="heal"){
      const cost = 3;
      if(player.mp < cost){
        log("Not enough MP to Heal.");
        return;
      }
      player.mp -= cost;
      const heal = RNG(4,7); // small heal feel-good
      player.hp = clamp(player.hp + heal, 0, player.hpMax);
      log(`Salem casts HEAL (+${heal} HP, -${cost} MP).`);
    } else {
      // Damage tuning: quick feel — Slash 5-9, Fire 6-10, Water 5-9
      let dmg = 0;
      if(kind==="slash") dmg = RNG(5,9);
      if(kind==="fire")  dmg = RNG(6,10);
      if(kind==="water") dmg = RNG(5,9);

      enemy.hp = clamp(enemy.hp - dmg, 0, enemy.hpMax);
      log(`Salem uses ${kind.toUpperCase()} on ${enemy.label} for ${dmg} damage.`);

      if(enemy.hp<=0){
        enemy.alive = false;
        log(`${enemy.label} is defeated.`);
      }
    }

    if(endIfOver()) return;

    // advance turn after player action
    nextTurn();
    waitingForPlayer = (currentToken()==="P1"||currentToken()==="P2");
    syncDebug();
  }

  // Advance (Start / Continue)
  function continueFlow(){
    if(!running){
      running = true;
      waitingForPlayer = (currentToken()==="P1"||currentToken()==="P2");
      log(`Two enemies ready. (Stats hidden)`);
      log(`Your turn: Salem (Action 1).`);
      syncDebug();
      return;
    }

    if(endIfOver()) return;

    const tok = currentToken();

    if(tok==="E1" || tok==="E2"){
      waitingForPlayer = false;

      const idx = tok==="E1" ? 0 : 1;
      const enemy = enemies[idx];

      if(enemy && enemy.alive){
        enemyAutoAttack(enemy);
      } else {
        if(debug) log(`${tok} skipped (dead).`);
      }

      if(endIfOver()) return;

      nextTurn();
      waitingForPlayer = (currentToken()==="P1"||currentToken()==="P2");
      if(waitingForPlayer){
        const actNum = currentToken()==="P1" ? 1 : 2;
        log(`Your turn: Salem (Action ${actNum}).`);
      } else {
        if(debug) log(`Enemy queued: ${currentToken()}`);
      }
      syncDebug();
      return;
    }

    // If it's player turn, Start/Continue just reminds you to pick an action
    if(tok==="P1"||tok==="P2"){
      const actNum = tok==="P1" ? 1 : 2;
      log(`Your turn: Salem (Action ${actNum}). Choose an action.`);
      waitingForPlayer = true;
      syncDebug();
    }
  }

  // -------------------------
  // Target selection (tap canvas or buttons)
  // -------------------------
  function setTarget(i){
    targetIndex = i;
    ensureValidTarget();
    log(`Targeting: ${enemies[targetIndex]?.label || ("Enemy "+(targetIndex+1))}.`);
  }

  t1Btn.addEventListener("click", ()=>setTarget(0));
  t2Btn.addEventListener("click", ()=>setTarget(1));

  // tap on canvas -> target
  canvas.addEventListener("click", (ev)=>{
    const rect = canvas.getBoundingClientRect();
    const sx = (ev.clientX - rect.left) / rect.width * W;
    const sy = (ev.clientY - rect.top) / rect.height * H;

    // crude hitboxes
    const hit = (pos)=> (sx >= pos.x && sx <= pos.x+14 && sy >= pos.y+6 && sy <= pos.y+22);
    if(hit(scene.enemy1)) setTarget(0);
    else if(hit(scene.enemy2)) setTarget(1);
  }, {passive:true});

  // -------------------------
  // Buttons
  // -------------------------
  startBtn.addEventListener("click", continueFlow);
  resetBtn.addEventListener("click", resetBattle);
  debugBtn.addEventListener("click", ()=>{
    debug = !debug;
    debugBtn.textContent = "Debug: " + (debug ? "ON" : "OFF");
    syncDebug();
  });

  slashBtn.addEventListener("click", ()=>playerAttack("slash"));
  fireBtn.addEventListener("click",  ()=>playerAttack("fire"));
  waterBtn.addEventListener("click", ()=>playerAttack("water"));
  healBtn.addEventListener("click",  ()=>playerAttack("heal"));

  function syncDebug(){
    if(!debug) return;
    console.log({
      running, waitingForPlayer, turnIndex, token: currentToken(),
      p: {...player},
      enemies: enemies.map(e=>({label:e.label,type:e.type,hp:e.hp,alive:e.alive}))
    });
  }

  // -------------------------
  // Reset + Enemy setup
  // -------------------------
  function resetBattle(){
    player.hp = player.hpMax = 32;
    player.mp = player.mpMax = 25;
    player.lvl = 7;
    player.xp = 25;
    enemies = [ makeEnemy("slime","Enemy 1"), makeEnemy("bandit","Enemy 2") ];
    targetIndex = 0;
    turnIndex = 0;
    round = 1;
    running = false;
    waitingForPlayer = true;
    logLines = [];
    log("Tap Start / Continue to begin.");
    syncDebug();
  }

  // init
  resetBattle();
  render();

})();
</script>
</body>
</html>
